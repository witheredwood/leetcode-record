# 【Leetcode之字符串】0028 实现strStr()

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/reverse-string

实现语言：Java

@[TOC](目录)

##  题目

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

**示例**

```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

## 方法：KMP

KMP算法是一种改进的字符串匹配算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个 next() 函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度是 O(m+n)。

KMP中，主串的指针不会后退。

求解 next() 的过程：

next() 数组中的值意思是：当前模式串t中有几个字符与主串s相等。

- 初始条件：cnext[0] = 0, next[1] = 1。
- 从1开始，比较当前字符 t[i] 和前一个字符 t[i-1]，将结果填入下一个字符的next() 中。
- 如果相等，当前字符的next() 的值是 前一个字符的next() 值加1。
- 如果不相等，比较当前字符 t[i] 和 

**代码实现**

```java
class Solution {
    public void reverseString(char[] s) {
        char tmp;       
        for (int i=0,j=s.length-1; i<j; i++,j--) {
            tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
        }
    }
}
```

时间复杂度：O( n )

空间复杂度：O( 1 )

执行用时：1 ms

内存消耗：45.1 MB

